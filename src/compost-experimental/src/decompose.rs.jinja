{%- set MAX_ARITY = 12 -%}

use core::{
	marker::PhantomData,
	ops::{Deref, DerefMut},
};

// === ContextExtract === //

#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd, Default)]
pub struct ContextHole;

pub trait ContextExtract<T, D> {
    type Rest;

    fn extract(self) -> (T, Self::Rest);
}

pub struct IdentityDisambiguator;

impl<'r, T> ContextExtract<&'r mut T, IdentityDisambiguator> for &'r mut T {
    type Rest = ContextHole;

    fn extract(self) -> (&'r mut T, Self::Rest) {
        (self, ContextHole)
    }
}

impl<'r, T> ContextExtract<&'r T, IdentityDisambiguator> for &'r mut T {
    type Rest = &'r T;

    fn extract(self) -> (&'r T, Self::Rest) {
        (self, self)
    }
}

impl<'r, T> ContextExtract<&'r T, IdentityDisambiguator> for &'r T {
    type Rest = &'r T;

    fn extract(self) -> (&'r T, Self::Rest) {
        (self, self)
    }
}

pub struct DerefDisambiguator;

impl<'r, T: DerefMut> ContextExtract<&'r mut T::Target, DerefDisambiguator> for &'r mut T {
    type Rest = ContextHole;

    fn extract(self) -> (&'r mut T::Target, Self::Rest) {
        (self, ContextHole)
    }
}

impl<'r, T: Deref> ContextExtract<&'r T::Target, DerefDisambiguator> for &'r mut T {
    type Rest = &'r T;

    fn extract(self) -> (&'r T::Target, Self::Rest) {
        (self, self)
    }
}

impl<'r, T: Deref> ContextExtract<&'r T::Target, DerefDisambiguator> for &'r T {
    type Rest = &'r T;

    fn extract(self) -> (&'r T::Target, Self::Rest) {
        (self, self)
    }
}

pub struct TupleDisambiguator0<D>(D);

impl<'r, T, D, P0, P1> ContextExtract<T, TupleDisambiguator0<D>> for (P0, P1)
where
    P0: ContextExtract<T, D>,
{
    type Rest = (P0::Rest, P1);

    fn extract(self) -> (T, Self::Rest) {
        let (v, r) = self.0.extract();
        (v, (r, self.1))
    }
}

pub struct TupleDisambiguator1<D>(D);

impl<'r, T, D, P0, P1> ContextExtract<T, TupleDisambiguator1<D>> for (P0, P1)
where
    P1: ContextExtract<T, D>,
{
    type Rest = (P0, P1::Rest);

    fn extract(self) -> (T, Self::Rest) {
        let (v, r) = self.1.extract();
        (v, (self.0, r))
    }
}

// === Reduce === //

pub trait Reduce {
    type Reduced;

    fn reduce(self) -> Self::Reduced;
}

impl<T: ReduceNonTerminal> Reduce for T {
    type Reduced = T::ReducedNonTerminal;

    fn reduce(self) -> Self::Reduced {
        self.reduce_non_terminal()
    }
}

impl Reduce for ContextHole {
    type Reduced = ();

    fn reduce(self) -> Self::Reduced {
        ()
    }
}

pub trait ReduceNonTerminal {
    type ReducedNonTerminal;

    fn reduce_non_terminal(self) -> Self::ReducedNonTerminal;
}

impl<'r, T: ?Sized> ReduceNonTerminal for &'r T {
    type ReducedNonTerminal = Self;

    fn reduce_non_terminal(self) -> Self::ReducedNonTerminal {
        self
    }
}

impl<'r, T: ?Sized> ReduceNonTerminal for &'r mut T {
    type ReducedNonTerminal = Self;

    fn reduce_non_terminal(self) -> Self::ReducedNonTerminal {
        self
    }
}

impl<A: ReduceNonTerminal, B: ReduceNonTerminal> ReduceNonTerminal for (A, B) {
    type ReducedNonTerminal = (A::ReducedNonTerminal, B::ReducedNonTerminal);

    fn reduce_non_terminal(self) -> Self::ReducedNonTerminal {
        (self.0.reduce_non_terminal(), self.1.reduce_non_terminal())
    }
}

impl<A: ReduceNonTerminal> ReduceNonTerminal for (A, ContextHole) {
    type ReducedNonTerminal = A::ReducedNonTerminal;

    fn reduce_non_terminal(self) -> Self::ReducedNonTerminal {
        self.0.reduce_non_terminal()
    }
}

impl<B: ReduceNonTerminal> ReduceNonTerminal for (ContextHole, B) {
    type ReducedNonTerminal = B::ReducedNonTerminal;

    fn reduce_non_terminal(self) -> Self::ReducedNonTerminal {
        self.1.reduce_non_terminal()
    }
}

// === ConsTuple === //

pub trait ConsTuple<'r> {
    type Output;

    fn cons_tuple(&'r mut self) -> Self::Output;
}

impl<'p: 'r, 'r, T: ?Sized> ConsTuple<'r> for &'p T {
    type Output = &'r T;

    fn cons_tuple(&'r mut self) -> Self::Output {
        self
    }
}

impl<'p: 'r, 'r, T: ?Sized> ConsTuple<'r> for &'p mut T {
    type Output = &'r mut T;

    fn cons_tuple(&'r mut self) -> Self::Output {
        self
    }
}

{% for i in range(2, MAX_ARITY + 1) -%}
impl<'r, {% for j in range(0, i) -%}
    P{{j}}: ConsTuple<'r>{{"" if loop.last else ", "}}
{%- endfor -%}> ConsTuple<'r> for (
    {%- for j in range(0, i) %}P{{j}}{{"" if loop.last else ", "}}{{ "," if loop.first and loop.last else "" }}{% endfor -%}
) {
    type Output = {{""}}
        {%- for j in range(0, i - 1) -%}({%- endfor -%}
        {% for j in range(0, i) %}P{{j}}::Output{{"" if loop.first else ")"}}{{"" if loop.last else ", "}}{% endfor %};

    fn cons_tuple(&'r mut self) -> Self::Output {
        {% for j in range(0, i - 1) -%}({%- endfor -%}
        {% for j in range(0, i) %}self.{{j}}.cons_tuple(){{"" if loop.first else ")"}}{{"" if loop.last else ", "}}{% endfor %}
    }
}

{% endfor -%}

// === TupleBuilder === //

pub trait ContextExtractOrHole<T, D> {
    type OrHoleRest;

    fn extract_or_hole(self) -> (T, Self::OrHoleRest);
}

impl<E: ContextExtract<T, D>, T, D> ContextExtractOrHole<T, (D,)> for E {
    type OrHoleRest = E::Rest;

    fn extract_or_hole(self) -> (T, Self::OrHoleRest) {
        self.extract()
    }
}

impl<E> ContextExtractOrHole<TupleOutputHole, TupleOutputHole> for E {
    type OrHoleRest = E;

    fn extract_or_hole(self) -> (TupleOutputHole, Self) {
        (TupleOutputHole { _private: () }, self)
    }
}

pub struct TupleOutputHole {
    _private: (),
}

pub struct TupleBuilder<T> {
    _ty: PhantomData<T>,
}

impl<T> TupleBuilder<T> {
    pub fn new() -> Self {
        Self { _ty: PhantomData, }
    }

    pub fn inference_helper(&self) -> Option<T> {
        None
    }
}

pub trait TupleBuilderId<V, R>: Sized {
    fn id(self, v: V) -> (V, TupleBuilder<R>) {
        (v, TupleBuilder::new())
    }
}

impl TupleBuilderId<TupleOutputHole, ()> for TupleBuilder<()> {}

{% for i in range(1, MAX_ARITY + 1) -%}
impl<
    {%- for j in range(0, i) %}P{{j}}{{"" if loop.last else ", "}}{% endfor -%}
> TupleBuilderId<P0, (
    {%- for j in range(1, i) %}P{{j}}{{"" if loop.last else ", "}}{{ "," if loop.first and loop.last else "" }}{% endfor -%}
)> for TupleBuilder<(
    {%- for j in range(0, i) %}P{{j}}{{"" if loop.last else ", "}}{{ "," if loop.first and loop.last else "" }}{% endfor -%}
)> {}

{% endfor -%}

// === ArityTruncate === //

pub trait ArityTruncate<R> {
    fn truncate_arity(self) -> R;
}

{% for i in range(0, MAX_ARITY + 1) %}
{%- set truncate_tup -%}
({% for j in range(0, i) %}P{{j}}{{ "" if loop.last else ", " }}{{ "," if i == 1 else "" }}{% endfor %})
{%- endset -%}

{%- set full_paras -%}
{% for j in range(0, MAX_ARITY) %}P{{j}}{{ "" if loop.last else ", " }}{% endfor %}
{%- endset -%}
impl<{{full_paras}}> ArityTruncate<{{truncate_tup}}> for ({{full_paras}}) {
    fn truncate_arity(self) -> {{truncate_tup}} {
        ({% for j in range(0, i) %}self.{{j}}{{"" if loop.last else ", " }}{{ "," if i == 1 else ""}}{% endfor %})
    }
}

{% endfor -%}

// === Decompose === //

{% set MACROS_PREFIX = "$crate::macro_internal" -%}

#[macro_export]
macro_rules! decompose {
    // "Rest" decomposing expression
    (...$input:expr) => {
        {
            use {{MACROS_PREFIX}}::ConsTuple;
            let input = $input.cons_tuple();
            let builder = {{MACROS_PREFIX}}::TupleBuilder::new();

            match builder.inference_helper() {
                {{MACROS_PREFIX}}::Some(var) => {
                    fn any<T>() -> T {
                        loop {}
                    }
                    (var, any())
                },
                {{MACROS_PREFIX}}::None => {
                    {%- for j in range(0, MAX_ARITY) %}
                    let (v, input) = {{MACROS_PREFIX}}::ContextExtractOrHole::extract_or_hole(input);
                    let input = {{MACROS_PREFIX}}::Reduce::reduce(input);
                    let (p{{j}}, builder) = {{MACROS_PREFIX}}::TupleBuilderId::id(builder, v);{{"\n"}}
                    {%- endfor %}
                    let _builder = builder;

                    (
                        {{MACROS_PREFIX}}::ArityTruncate::truncate_arity((
                            {%- for j in range(0, MAX_ARITY) -%}
                            p{{j}}{{ "" if loop.last else ", " }}
                            {%- endfor -%}
                        )),
                        input,
                    )
                }
            }
        }
    };

	// Annotated "rest" decomposing expression
    (...$input:expr => (
        $($ty:ty),*$(,)?
    )) => {
        {{MACROS_PREFIX}}::identity::<(
            ($($ty,)*),
            _,
        )>($crate::decompose!(...$input))
    };

    // Regular decomposing expression
    ($input:expr) => {
        $crate::decompose!(...$input).0
    };

	// Annotated regular decomposing expression
    ($input:expr => (
        $($ty:ty),*$(,)?
    )) => {
        {{MACROS_PREFIX}}::identity::<($($ty,)*)>($crate::decompose!($input))
    };

	// "Rest" decomposing statement
    ($input:expr => $rest:ident & {
        $($name:ident: $ty:ty),*
        $(,)?
    }) => {
        #[allow(unnecessary_mut)]
        let (($($name,)*), mut $rest): (($($ty,)*), _) = $crate::decompose!(...$input);
    };

    // Regular decomposing statement
    ($input:expr => {
        $($name:ident: $ty:ty),*
        $(,)?
    }) => {
        $crate::decompose!($input => _ignored & { $($name:$ty),* });
    };
}{{"\n"}}
