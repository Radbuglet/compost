{%- set MAX_ARITY = 12 -%}

use core::{borrow::{Borrow, BorrowMut}, marker::PhantomData, ptr::NonNull};

// === Tuple Expansion === //

#[doc(hidden)]
pub struct TupleRemainder<T>(pub T);

#[doc(hidden)]
pub struct TupleInputHole {
	_private: (),
}

impl TupleInputHole {
	fn new_mut<'a>() -> &'a mut Self {
		unsafe {
			// Safety: ZSTs can dangle.
			NonNull::<Self>::dangling().as_mut()
		}
	}
}

// First, we define a mechanism for expanding all input tuples to tuples of the same arity.
#[doc(hidden)]
pub trait NormalizeArity<'a> {
	type Target;

	fn normalize_arity(&'a mut self) -> Self::Target;
}

{% for i in range(0, MAX_ARITY + 1) -%}
impl<'a{{ ", " if i > 0 else "" }}
	{%- for j in range(0, i) %}P{{j}}: 'a{{ '' if loop.last else ', ' }}{% endfor -%}
> NormalizeArity<'a> for (
	{%- for j in range(0, i) %}P{{j}}{{ '' if loop.last else ', ' }}{{ "," if i == 1 else "" }}{% endfor -%}
) {
	type Target = ({% for j in range(0, MAX_ARITY) %}&'a mut {{ "P" ~ j if j < i else "TupleInputHole" }}{{ '' if loop.last else ', ' }}{% endfor %});

	fn normalize_arity(&'a mut self) -> Self::Target {
		({% for j in range(0, MAX_ARITY) %}{{ "&mut self." ~ j if j < i else "TupleInputHole::new_mut()" }}{{ '' if loop.last else ', ' }}{% endfor %})
	}
}

{% endfor -%}

impl<'a: 'b, 'b, {%- for j in range(0, MAX_ARITY) %}P{{j}}: 'a{{ '' if loop.last else ', ' }}{% endfor -%}> NormalizeArity<'b> for TupleRemainder<(
	{%- for j in range(0, MAX_ARITY) %}&'a mut P{{j}}{{ '' if loop.last else ', ' }}{% endfor -%}
)> {
	type Target = ({%- for j in range(0, MAX_ARITY) %}&'b mut P{{j}}{{ '' if loop.last else ', ' }}{% endfor -%});

	fn normalize_arity(&'b mut self) -> Self::Target {
		let me = &mut self.0;

		({%- for j in range(0, MAX_ARITY) %}&mut me.{{j}}{{ '' if loop.last else ', ' }}{% endfor -%})
	}
}

// === Tuple output inference === //

#[doc(hidden)]
pub struct TupleOutputHole {
	_private: (),
}

// Next, we define a `TupleBuilder.
//
// First, by calling `inference_helper()` and pretending to return this as the expression value on a
// match with `Some(T)` (`inference_helper` always returns `None`), the `decompose!` macro can infer
// the type of the tuple being returned—type `T`.
//
// For a given `TupleBuilder<(P0, P1, ...)>`, the `id()` method takes a parameter of type `P0`, returns
// that value, and produces a new builder of type `TupleBuilder<(P1, P2, ...)>`. Thus, by calling
// `id(T)` repeatedly, we can force the inference engine to infer the type of the expression passed to the
// method.
//
// In the case of a `TupleBuilder<()>`, `id` will default to expecting a value of type `TupleOutputHole`.
#[doc(hidden)]
pub struct TupleBuilder<T> {
	_ty: PhantomData<T>,
}

impl<T> TupleBuilder<T> {
	pub fn new() -> Self {
		Self { _ty: PhantomData, }
	}

	pub fn inference_helper(&self) -> Option<T> {
		None
	}
}

pub trait TupleBuilderId<V, R>: Sized {
	fn id(self, v: V) -> (V, TupleBuilder<R>) {
		(v, TupleBuilder::new())
	}
}

impl TupleBuilderId<TupleOutputHole, ()> for TupleBuilder<()> {}

{% for i in range(1, MAX_ARITY + 1) -%}

{%- set para_list_1plus %}{% for j in range(1, i) -%}
	P{{j}}{{ '' if loop.last else ', ' }}
{%- endfor %}{% endset -%}

{%- set para_list -%}
	P0,{{ ' ' if i > 1 else '' }}{{ para_list_1plus }}
{%- endset -%}

impl<{{para_list}}> TupleBuilderId<P0, ({{para_list_1plus}}{{ ',' if i == 2 else '' }})> for TupleBuilder<({{para_list}})> {}
{% endfor -%}

// === Tuple searching === //

// Now, we define a way to search a tuple of arity `MAX_ARITY`.
pub trait TupleSearch<T, R, V> {
	fn search(self) -> (T, R);
}

impl<T> TupleSearch<TupleOutputHole, Self, ()> for T {
	fn search(self) -> (TupleOutputHole, Self) {
		(TupleOutputHole { _private: () }, self)
	}
}

{% for i in range(0, MAX_ARITY) -%}
pub struct Disambiguator{{i}} { _private: () }
{% set rest_tup -%}
({%- for j in range(0, MAX_ARITY) %}{{ "&'a mut P" ~ j if j != i else "&'a mut TupleInputHole" }}{{ '' if loop.last else ', ' }}{% endfor -%})
{%- endset -%}

{% for is_mut in [false, true] %}
impl<'a, T: ?Sized, {{""}}
	{%- for j in range(0, MAX_ARITY) %}P{{j}}{{ '' if loop.last else ', ' }}{% endfor -%}
> TupleSearch<&'a {{ "mut " if is_mut else "" }}T, {{rest_tup}}, Disambiguator{{i}}> for ({%- for j in range(0, MAX_ARITY) %}{{ "&'a mut P" ~ j }}{{ '' if loop.last else ', ' }}{% endfor -%})
where
	P{{i}}: Borrow{{ "Mut" if is_mut else "" }}<T>,
{
	fn search(self) -> (&'a {{ "mut" if is_mut else "" }} T, {{rest_tup}}) {
		((*self.{{i}}).borrow{{ "_mut" if is_mut else "" }}(), (
			{%- for j in range(0, MAX_ARITY) %}{{ "self." ~ j if j != i else "TupleInputHole::new_mut()" }}{{ '' if loop.last else ', ' }}{% endfor -%}
		))
	}
}
{% endfor %}
{% endfor -%}

// === Tuple truncation === //

// Finally, we define a mechanism for truncating the end off a tuple. This is used to get rid of the
// trailing `TupleOutputHole` instances emitted at the end of the tuple once all required components
// have been acquired.
pub trait ArityTruncate<R> {
	fn truncate_arity(self) -> R;
}

{% for i in range(0, MAX_ARITY + 1) %}
{%- set truncate_tup -%}
({% for j in range(0, i) %}P{{j}}{{ "" if loop.last else ", " }}{{ "," if i == 1 else "" }}{% endfor %})
{%- endset -%}

{%- set full_paras -%}
{% for j in range(0, MAX_ARITY) %}P{{j}}{{ "" if loop.last else ", " }}{% endfor %}
{%- endset -%}
impl<{{full_paras}}> ArityTruncate<{{truncate_tup}}> for ({{full_paras}}) {
	fn truncate_arity(self) -> {{truncate_tup}} {
		({% for j in range(0, i) %}self.{{j}}{{"" if loop.last else ", " }}{{ "," if i == 1 else ""}}{% endfor %})
	}
}

{% endfor -%}

// === Macro definition === //

{% set MACROS_PREFIX = "$crate::macros" -%}

/// This macro takes a **mutable reference** to a tuple and decomposes it into a sub-tuple
/// (i.e. a tuple containing a subset of the values contained in the parent tuple).
///
/// ## Syntax
///
/// There are two ways in which this macro can be used...
/// 
/// ...in an **expression**:
///
/// ```
/// use compost::decompose;
///
/// let mut input = (1i32, &mut 2u32, 'c');
///
/// fn example(cx: (&i32, &mut u32)) {
/// 	dbg!(cx);
/// }
/// 
/// // Can be used when calling a function...
/// example(decompose!(input));
///
/// // ...or when assigning to a variable.
/// let cx_subset: (&mut u32, &mut char) = decompose!(input);
/// ```
///
/// ...in a **statement:**
///
/// ```
/// use compost::decompose;
///
/// let mut input = (1i32, &mut 2u32, 'c', 1.3f32);
///
/// // Brings component references into scope and produces
/// // a `rest` value containing the remaining components.
/// //
/// // NOTE: Because `rest`'s tuple layout is unspecified, `rest`
/// // is new-typed in a macro-internal `TupleRemainder` struct.
/// decompose!(input => rest & {
///		my_char: &mut char,
/// 	my_i32: &i32,
/// });
///
/// dbg!((my_char, my_i32));
///
/// // `rest` can itself be decomposed several times.
/// decompose!(rest => rest & { my_u32: &u32 });
///
/// // If you're done decomposing, you can omit the `rest` parameter.
/// decompose!(rest => { my_f32: &mut f32 });
/// 
/// dbg!((my_u32, my_f32));  // (borrows from multiple decompose statements simultaneously)
/// dbg!(my_i32);  // (remains valid!)
/// ```
///
/// ...in a **combination of both**:
///
/// ```
/// use compost::decompose;
///
/// struct MyThing {
/// # /*
/// 	...
/// # */
/// }
///
/// impl MyThing {
///		pub fn do_something(&mut self, deps: (&u32, &mut i32, &char)) {
/// 		dbg!(deps);
/// 	}
/// }
///
/// fn do_something(mut cx: (&mut MyThing, &mut u32, &mut i32, char)) {
///		decompose!(cx => cx_rest & { thing: &mut MyThing });
/// 	thing.do_something(decompose!(cx_rest));
///
/// 	decompose!(cx => { my_char: &char });
///		dbg!(my_char);
/// }
///
/// ```
///
/// ## What Can Be Borrowed?
///
/// **Rule 1:** `decompose!` expects a mutable reference to the tuple it is decomposing. Thus, this is not valid:
///
/// ```compile_fail
/// use compost::decompose;
///
/// fn example(cx: (&i32, &u32)) {
///		decompose!(cx => { my_i32: &i32 });
///		dbg!(my_i32);
/// }
/// ```
///
/// but this is:
///
/// ```
/// use compost::decompose;
///
/// fn example(mut cx: (&i32, &u32)) {  // (see how the `cx` variable itself is now mut?)
///		decompose!(cx => { my_i32: &i32 });
///		dbg!(my_i32);
/// }
/// ```
///
/// **Rule 2:** `decompose!` always decomposes tuples into tuples, even if they're **single element tuples.**
/// 
/// Thus, this is not valid:
///
/// ```compile_fail
/// use compost::decompose;
///
/// fn takes_cx(cx: &i32) {
/// 	dbg!(cx);
/// }
/// 
///	fn example(mut cx: (&i32, &u32)) {
/// 	takes_cx(decompose!(cx));
/// }
/// ```
///
/// ...but this is:
///
/// ```
/// use compost::decompose;
///
/// fn takes_cx(cx: (&i32,)) {  // (notice the trailing comma?)
/// 	dbg!(cx);
/// }
/// 
///	fn example(mut cx: (&i32, &u32)) {
/// 	takes_cx(decompose!(cx));
/// }
/// ```
///
/// Note the **trailing comma** in `(&i32,)`, which differentiates single element tuples from
/// grouping parentheses around types.
///
/// **Rule 3:** Components in the input tuple can be anything. They can be references, mutable references, smart pointers,
/// owned instances, etc. However, components in the output tuple must be **immutable or mutable** references.
/// 
/// A reference can be decomposed from an input tuple if the input tuple has some element that implements [`Borrow<T>`](Borrow)
/// (or [`BorrowMut<T>`](BorrowMut) if the reference being requested is mutable) to that specific type `T`.
///
/// ```
/// use core::borrow::Borrow;
/// use compost::decompose;
///
/// fn example<T: Borrow<V>, V>(mut cx: (T,)) {
///		decompose!(cx => { v: &V });
///
/// 	// Of course, you can still borrow the original value as well...
/// 	decompose!(cx => { v: &mut T });
/// }
/// ```
///
/// Note that the **actual element itself** must implement `Borrow` so, while `T: Borrow<V>`—
/// making it possible to decompose `&V` from an **owned** instance of `T`—`&'_ T` does not, making
/// that decomposition invalid. You'd need to adjust your generic parameter bounds to make that work:
/// 
/// ```
/// use core::borrow::Borrow;
/// use compost::decompose;
///
/// fn example<'a, T, V>(mut cx: (&'a mut T,))
/// where
///		&'a mut T: Borrow<V>,
///  {
///		decompose!(cx => { v: &V });
/// }
/// ```
///
/// ## Caveats
///
/// **Caveat 1:** Because variadic tuples are not a thing yet, the maximum arity of (number of elements in)
/// both the input and output tuples is **{{MAX_ARITY}}**. This value is configurable in the source code
/// (see: `src/generated/decompose.rs.jinja`'s `MAX_ARITY` template variable).
///
/// **Caveat 2:** Because `decompose!` consumes a mutable reference to the tuple being decomposed:
///
/// 1. The tuple must be marked as mutable (but you already knew that).
/// 2. Tuple temporaries cannot be decomposed and returned from the function.
///
/// Thus, this fails to compile:
///
/// ```compile_fail
/// use compost::decompose;
///
/// fn give_me_some_things<'a>(mut cx: (&'a u32, &'a mut i32)) -> (&'a u32, &'a i32) {
///		decompose!(cx)
/// }
/// ```
#[macro_export]
macro_rules! decompose {
	($input:expr) => {
		{
			use {{MACROS_PREFIX}}::NormalizeArity;
			let input = $input.normalize_arity();
			let builder = {{MACROS_PREFIX}}::TupleBuilder::new();
			
			match builder.inference_helper() {
				{{MACROS_PREFIX}}::Some(var) => var,
				{{MACROS_PREFIX}}::None => {
					{%- for j in range(0, MAX_ARITY) %}
					let (v, input) = {{MACROS_PREFIX}}::TupleSearch::search(input);
					let (p{{j}}, builder) = {{MACROS_PREFIX}}::TupleBuilderId::id(builder, v);
					{% endfor %}

					let _builder = builder;
					let _input = input;

					{{MACROS_PREFIX}}::ArityTruncate::truncate_arity((
						{%- for j in range(0, MAX_ARITY) -%}
						p{{j}}{{ "" if loop.last else ", " }}
						{%- endfor -%}
					))
				}
			}
		}
	};
	($input:expr => $rest:ident & {
		$($name:ident: $ty:ty),*
		$(,)?
	}) => {
		#[allow(unnecessary_mut)]
		let (($($name,)*), mut $rest): (($($ty,)*), _) = {
			use {{MACROS_PREFIX}}::NormalizeArity;
			let input = $input.normalize_arity();
			let builder = {{MACROS_PREFIX}}::TupleBuilder::new();
			
			match builder.inference_helper() {
				#[allow(unreachable_code)]
				{{MACROS_PREFIX}}::Some(var) => (var, loop {}),
				{{MACROS_PREFIX}}::None => {
					{%- for j in range(0, MAX_ARITY) %}
					let (v, input) = {{MACROS_PREFIX}}::TupleSearch::search(input);
					let (p{{j}}, builder) = {{MACROS_PREFIX}}::TupleBuilderId::id(builder, v);
					{% endfor %}

					let _builder = builder;

					({{MACROS_PREFIX}}::ArityTruncate::truncate_arity((
						{%- for j in range(0, MAX_ARITY) -%}
						p{{j}}{{ "" if loop.last else ", " }}
						{%- endfor -%}
					)), {{MACROS_PREFIX}}::TupleRemainder(input))
				}
			}
		};
	};
	($input:expr => {
		$($name:ident: $ty:ty),*
		$(,)?
	}) => {
		$crate::decompose!($input => _ignored & { $($name:$ty),* });
	}
}
